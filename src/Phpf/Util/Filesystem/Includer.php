<?php
/**
 * A modified version of Aura's Includer.
 *
 * {@link https://github.com/auraphp/Aura.Includer/blob/develop-2/src/Includer.php}
 * @package Phpf.Util
 * @subpackage Filesystem.Includer
 */

namespace Phpf\Util\Filesystem;
 
class Includer {
	
	const DIR_ORDER = 'dir_order';
 
    const FILE_ORDER = 'file_order';
	
	protected $dirs = array();
	
	protected $files = array();
	
	protected $vars = array();
	
	protected $paths = array();
	
	protected $debug = array();
	
	protected $cache_file;
	
	protected $strict = true;
	
	protected $limited_include;
	
	function __construct(){
		 $this->limited_include = function( $__FILE__, array $__VARS__ ){
            unset($__VARS__['__FILE__']);
            extract($__VARS__);
            unset($__VARS__);
            include $__FILE__;
        };
	}

	/**
	 * Returns debug information generated by `getPaths()`, etc.
	 *
	 * @return array
	 */
    public function get_debug(){
        return $this->debug;
    }
    
    /**
	 * Sets strict mode.
	 *
	 * @param bool $strict Whether or not to operate in strict mode.
	 * @return null
	 */
    public function set_strict( $strict ){
        $this->strict = (bool) $strict;
    }
    
    /**
	 * Is the includer in strict mode?
	 *
	 * @return bool True for strict mode, false for not.
	 */
    public function is_strict(){
        return $this->strict;
    }
	
	public function add_dir( $dir ){
		$dir = str_replace('/', DIRECTORY_SEPARATOR, $dir);
        $dir = rtrim($dir, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
		$this->dirs[] = $dir;
		return $this;
	}
	
    /**
	* Adds directories to traverse through; appends to the existing
	* directories.
	*
	* @param array $dirs The directories to traverse through.
	* @return null
	*/
	public function add_dirs( array $dirs ){
		foreach($dirs as $dir){
			$this->add_dir( $dir );
		}
		return $this;
	}
	
	/**
	 * Sets the directories to traverse through; clears all previous
	 * directories.
	 *
	 * @param array $dirs The directories to traverse through.
	 * @return null
	 */
	public function set_dirs( array $dirs ){
		$this->dirs = array();
		return $this->add_dirs( $dirs );
	}
	
	public function get_dirs(){
		return $this->dirs;
	}
	  
    /**
	 * Adds one file to look for in the directories.
	 *
	 * @param string $file The file to look for.
	 * @return null
	 */
	public function add_file( $file ){
		$file = str_replace('/', DIRECTORY_SEPARATOR, $file);
		$this->files[] = $file;
		return $this;
	}
	
	/**
	 * Adds files to to look for in the directories; appends to the existing
	 * files.
	 *
	 * @param array $files The files to look for.
	 * @return null
	 */
	public function add_files( array $files ){
		foreach( $files as $file ){
			$this->add_file( $file );
		}
		return $this;
	}
	
	/**
	 * Sets the files to look for in the directories; clears all previous
	 * files.
	 *
	 * @param array $files The files to look for.
	 * @return null
	 */
	public function set_files( array $files ){
		$this->files = array();
		return $this->add_files( $files );
	}
	
	public function get_files(){
		return $this->files;
	}
	
	public function add_var( $var, $val ){
		if ( ! isset( $this->vars[ $var ] ) )
			$this->vars[ $var ] = $val;
		return $this;
	}
	
	public function set_var( $var, $val ){
		$this->vars[ $var ] = $val;
		return $this;
	}
	
	/**
	* merge the variables to extract inside the limited include scope.
	*
	* @param array $vars The variables to extract inside the limited include
	* scope.
	* @return null
	*/
	public function add_vars(array $vars){
        $this->vars = array_merge( $this->vars, $vars );
    	return $this;
	}
	 
    /**
	 * Sets the variables to extract inside the limited include scope.
	 *
	 * @param array $vars The variables to extract inside the limited include
	 * scope.
	 * @return null
	 */
	public function set_vars( array $vars ){
		$this->vars = $vars;
		return $this;
	}
	
	public function get_vars(){
		return $this->vars;
	}
	
    /**
	 * Include the paths combined from the directories and files.
	 *
	 * @param string $order Combine the paths in this order; self::DIR_ORDER
	 * to look for all files in each directory first, or self::FILE_ORDER to
	 * look through all directories for each file first.
	 * @return null
	 */
	public function load( $order = self::DIR_ORDER ){
		
        $limited_include = $this->limited_include;
        
        if ( $this->cache_file && is_readable($this->cache_file) ) {
            $this->debug = array("Load: {$this->cache_file}");
            $limited_include($this->cache_file, $this->vars);
            return;
        }
        
        $paths = $this->get_paths( $order );
        foreach ( $paths as $path ) {
            $this->debug[] = "Load: $path";
            $limited_include($path, $this->vars);
        }
    }
	
    /**
	 * Gets the list of paths to look for, combined from the directories and
	 * files; returns only paths that exist and are readable.
	 *
	 * @param string $order Combine the paths in this order; self::DIR_ORDER
	 * to look for all files in each directory first, or self::FILE_ORDER to
	 * look through all directories for each file first.
	 *
	 * @return array The readable paths combined from the directories and
	 * files.
	 */
	public function get_paths( $order = self::DIR_ORDER ){
        	
        $this->debug = array(
            "Order: $order",
            "Strict: " . ($this->is_strict() ? 'true' : 'false'),
        );
        
        if ( $order == self::DIR_ORDER ) {
            return $this->getPathsByDirOrder();
        }
        
        if ( $order == self::FILE_ORDER ) {
            return $this->getPathsByFileOrder();
        }
        
        throw new Exception("No such file order");
    }
	 
    /**
	 * Returns the paths in directory-first order.
	 *
	 * @return array
	 */
	protected function getPathsByDirOrder(){
		$this->paths = array();
        foreach ($this->dirs as $dir) {
            foreach ($this->files as $file) {
                $this->addGlob($dir, $file);
            }
        }
        return $this->paths;
    }
	
	/**
	 * Returns the paths in file-first order.
	 *
	 * @return array
	*/
	protected function getPathsByFileOrder(){
      	$this->paths = array();
        foreach ($this->files as $file) {
            foreach ($this->dirs as $dir) {
                $this->addGlob($dir, $file);
            }
        }
        return $this->paths;
    }
	
	/**
	 * Given a directory and a file spec, globs them for file paths, and adds
	 * them if they are found.
	 *
	 * @param string $dir The directory to glob.
 	 * @param string $file The file to glob.
	 * @return null
	 */
	protected function addGlob($dir, $file){
    
	    $glob = glob($dir . $file);
        
        // error or no results?
        if ( ! $glob ) {
            return;
        }
        
        foreach ($glob as $path) {
            
            // strict?
            if ( ! $this->strict ) {
                $this->paths[] = $path;
                $this->debug[] = "Found: $path";
                continue;
            }
        
            // convert the path to its real location so that directory checks
            // work properly, even with directory traversal.
            $path = realpath($path);
        
            // is the file actually in the specified directory?
            // this will fail with symlinks.
            $dir_len = strlen($dir);
            if (substr($path, 0, $dir_len) != $dir) {
                // not actually in the directory, don't retain it
                $this->debug[] = "Not found (directory): $path";
                continue;
            }
        
            // retain the real path
            $this->paths[] = $path;
            $this->debug[] = "Found: $path";
        }
    }

}